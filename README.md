# 기술 스택

- **프론트엔드**: Next.js 15, Tailwind CSS v4, Storybook, Zustand, TanStack Query
- **백엔드**: Express, Cookie Parser

## 실행 환경 

```
node -v // v22.17.0
```

## 실행 방법

### Mock 서버 실행

```bash
yarn mock
```

Mock 서버가 `localhost:9090`에서 실행됩니다.

### 프론트엔드 서버 실행

```bash
yarn dev
```

프론트엔드 서버가 `localhost:3000`에서 실행됩니다.

### 접속

(두 개의 터미널에서 각각의 서버를 띄워주시면 감사하겠습니다)

- 프론트엔드: http://localhost:3000
- Mock API 서버: http://localhost:9090

#### 인증 시스템

1. **회원가입**: 사용자가 가입하면 `authToken` 쿠키가 발행됩니다 (30일 유효)
2. **로그인**: `authToken`이 있으면 자동으로 로그인 상태가 됩니다
3. **접근 권한**: 로그인한 사용자만 강의 목록, 강의 생성 등의 기능을 사용할 수 있습니다

#### 데이터 저장 (백엔드)

- 모든 사용자 정보와 강의 정보는 메모리에만 저장됩니다
- 서버를 종료하면 모든 데이터가 사라집니다 (임시 저장)

### FSD 아키텍처

A. FSD 아키텍처
기능 중심으로 폴더를 구성, 도메인 로직과 UI 컴포넌트를 확실하게 분리, 계층화를 효과적으로 하기 위해 FSD 아키텍처를 적용하였습니다. 뿐만 아니라 FSD 의존성 규칙(“상위 폴더(레이어)의 함수는 직접 사용할 수 없고, 오직 자신과 하위계층에서 공개된 API만 사용할 수 있다.”) 이 규칙을 통해 단일 의존성 방향을 보장하여 서버 컴포넌트와 클라이언트 컴포넌트를 쉽게 구분할 수 있습니다.

- FSD 공식문서를 토대로 각 폴더의 역할과 책임은 다음과 같이 정의하였습니다.

- app: 애플리케이션 초기화 및 글로벌 설정 (ex. provider, router 설정)

- pages: 말 그대로 pages를 의미

- widget: features 컴포넌트를 묶음 단위로 사용

- features: 사용자 시나리오와 도메인 로직 기능을 담당하는 컴포넌트를 선언

\*entities: entities는 비즈니스 엔티티를 다루는 레이어로, 서버에서 받은 데이터와 기능을 프론트엔드 관점(상태)에 맞춰 매핑하고 변환하는 역할을 담당합니다.

즉, 서버 데이터와 화면에서 실제로 필요한 데이터 사이의 간극을 줄여주는 매핑 레이어라고 보시면 됩니다.
( 또한, tanstack-query가 “서버 상태”를 관리하기 때문에, 이와 관련된 로직 역시 대부분 이 레이어에서 처리하도록 구성했습니다. )

shared: 공용 스타일, 공용 커스텀 훅, 공용 함수, 공용 UI 컴포넌트, 유틸리티한 함수와 컴포넌트를 정의

### SSR

강의 목록 페이지 서버 사이드 렌더링을 구현했습니다.

강의 목록 페이지에서 다양한 정렬 옵션별로 데이터를 미리 prefetch하여 SSR을 구현했습니다. 이를 통해 사용자가 정렬 옵션을 변경할 때 즉시 데이터를 표시할 수 있도록 성능을 최적화했습니다.

### 공용 컴포넌트 설계 방법

평소 리액트 컴포넌트를 개발하면서 기능 + UI 결합된 형태로 컴포넌트를 개발할 경우 확장성이 떨어진다는 문제점을 겪고 있었습니다.

따라서 UI 없이 로직, 혹은 필요한 기능이나 스타일만 제공하는 "Headless 컴포넌트"를 구축, 변동 사항이 많은 스타일은 props나 children을 통해 제어권을 넘겨주어 컴포넌트를 설계하도록 구성하였습니다.

뿐만 아니라 UI 기능이 복잡한 경우 "합성 컴포넌트 패턴" ( SRP 원칙을 지킨 작은 기능들의 컴포넌트의 조합 ) 을 적용하여 확장성이 높은 컴포넌트을 설계하였습니다.

### 테스트

Storybook을 활용해 애플리케이션의 비즈니스 로직이나 데이터 의존성 없이, 순수하게 컴포넌트 자체만을 렌더링하고 테스트하고, 추상화된 UI 컴포넌트들을 격리된 환경에서 개발하고 테스트할 수 있게 해주기 때문에 사용했습니다.

Storybook을 활용한 컴포넌트 기반 개발(CDD)을 통해:

- **격리된 환경**: 비즈니스 로직이나 데이터 의존성 없이 순수한 컴포넌트만 테스트
- **재사용성**: 추상화된 UI 컴포넌트들을 독립적으로 개발하고 테스트
- **시각적 테스트**: 다양한 props와 상태에 따른 컴포넌트 렌더링 결과 확인

### 에러 핸들링 방법

- 1. 서버 컴포넌트 (인증)
     (로그인 유저만 볼 수 있는 컨텐츠) -> 유저 볼 수 있게
     ( 로그인 하지 않은 유저만 볼 수있는컨텐츠) -> 로그인 유저가 볼 수 없게

- 2. mutation error (POST 요청 에러)
     post 요청 후 API 에러 응답을 받을 경우 modal을 통해 안내 메세지를 주고 있습니다.

- 3. query error
     global-error에서 처리

- 4. 예상치 못한 에러
     global-error에서 처리

### 시멘틱 태그

```
1. <form>: 폼 제출과 유효성 검사를 위한 시멘틱 구조
2. <fieldset>: 라디오 버튼 그룹을 논리적으로 묶음
3. <input type="radio">: 단일 선택을 위한 시멘틱 태그
4. <input type="checkbox">: 다중 선택을 위한 시멘틱 태그
5. <label>: 접근성을 위한 입력 요소와의 연결
6. <button>: 사용자 액션을 위한 시멘틱 태그
7. role="group": ARIA 역할을 통한 접근성 향상
8. aria-labelledby: 요소 간의 관계 명시
9. aria-checked: 상태 정보 제공
10. sr-only: 스크린 리더 전용 요소
이러한 시멘틱 태그 사용으로 웹 접근성, SEO 최적화, 코드 가독성을 모두 향상시켰습니다! 🎉
```
